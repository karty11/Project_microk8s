name: deploy bankapp + mysql (ArgoCD + ESO + ArgoCD Install)

# on:
#  workflow_run:
#    workflows: [ "CI Pipeline" ]
#    types:
# #      - completed
on:
  workflow_dispatch:  # <-- manual trigger only

env:
  KUBE_NAMESPACE: devproject
  EXTERNAL_SECRETS_NAMESPACE: external-secrets
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  prepare_kube:
    name: Prepare kubeconfig & namespaces
    runs-on: [self-hosted]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubeconfig (if provided as secret)
        if: ${{ secrets.KUBECONFIG_DATA != '' }}
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 --decode > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Ensure devproject namespace exists
        run: kubectl create ns ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure external-secrets namespace exists
        run: kubectl create ns ${EXTERNAL_SECRETS_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure argocd namespace exists
        run: kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -

  install_argocd:
    name: Install Argo CD
    runs-on: [self-hosted]
    needs: prepare_kube
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if ArgoCD already installed (has deployment/argocd-server)
        id: check_argocd
        run: |
          if kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "installed=true" >> $GITHUB_OUTPUT
          else
            echo "installed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install ArgoCD (kubectl apply) if missing
        if: steps.check_argocd.outputs.installed == 'false'
        run: |
          echo "Installing ArgoCD from upstream manifest..."
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl -n argocd wait --for=condition=available deployment/argocd-server --timeout=4m || true
          kubectl -n argocd wait --for=condition=available deployment/argocd-application-controller --timeout=4m || true
          kubectl -n argocd wait --for=condition=available deployment/argocd-repo-server --timeout=4m || true
        timeout-minutes: 10

      - name: Wait for ArgoCD deployments to be ready
        run: |
          kubectl -n argocd rollout status deployment/argocd-server --timeout=180s
          kubectl -n argocd rollout status deployment/argocd-application-controller --timeout=180s
          kubectl -n argocd rollout status deployment/argocd-repo-server --timeout=180s

      - name: Show ArgoCD pods
        run: kubectl get pods -n argocd -o wide

  install_and_configure_eso:
    name: Install External Secrets Operator and configure AWS creds
    runs-on: [self-hosted]
    needs: install_argocd
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Add external-secrets Helm repo
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update

      - name: Install/Upgrade external-secrets (Helm)
        run: |
          helm upgrade --install external-secrets external-secrets/external-secrets \
            -n ${EXTERNAL_SECRETS_NAMESPACE} --create-namespace \
            --wait --timeout 5m

      - name: Wait for external-secrets controller to be ready
        run: |
          kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} rollout status deployment/external-secrets-controller --timeout=120s || true
          kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} get pods -o wide

      - name: Create or apply aws-creds k8s secret (prefer GitHub Secrets if file not present)
        env:
          AWS_ESO_AK: ${{ secrets.AWS_ESO_ACCESS_KEY_ID }}
          AWS_ESO_SK: ${{ secrets.AWS_ESO_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # If repo contains a file with aws-creds secret, apply it (but avoid committing real creds)
          if [ -f k8s/external-secrets/aws-creds-secret.yaml ]; then
            echo "Applying k8s/external-secrets/aws-creds-secret.yaml from repo (ensure it does NOT contain real keys in git)."
            kubectl apply -f k8s/external-secrets/aws-creds-secret.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}
          else
            echo "Creating aws-creds from GitHub Secrets into namespace ${EXTERNAL_SECRETS_NAMESPACE}"
            kubectl create secret generic aws-creds \
              -n ${EXTERNAL_SECRETS_NAMESPACE} \
              --from-literal=AWS_ACCESS_KEY_ID="${AWS_ESO_AK}" \
              --from-literal=AWS_SECRET_ACCESS_KEY="${AWS_ESO_SK}" \
              --from-literal=AWS_REGION="${AWS_REGION}" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

      - name: Apply SecretStore (points to aws-creds)
        run: kubectl apply -f k8s/external-secrets/secretstore-aws.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}

      - name: Apply ExternalSecret (creates bankapp-db-externalsecret in devproject)
        run: kubectl apply -f k8s/external-secrets/externalsecret-bankapp.yaml -n ${KUBE_NAMESPACE}

      - name: Wait for bankapp-db-externalsecret to appear
        run: |
          for i in {1..24}; do
            if kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} >/dev/null 2>&1; then
              echo "Secret exists."
              exit 0
            fi
            echo "Waiting for secret (attempt $i/24)..."
            sleep 5
          done
          echo "ERROR: secret not created after wait" >&2
          kubectl get externalsecret -n ${KUBE_NAMESPACE} -o yaml || true
          exit 1

  apply_argocd_apps:
    name: Apply ArgoCD Application manifests (mysql & bankapp)
    runs-on: [self-hosted]
    needs: install_and_configure_eso
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply ArgoCD MySQL Application manifest
        run: kubectl apply -f argocd/mysql-application.yaml -n argocd

      - name: Apply ArgoCD Bankapp Application manifest
        run: kubectl apply -f argocd/bankapp-application.yaml -n argocd

      - name: Wait for ArgoCD apps to show synced + healthy
        run: |
          set -e
          APPS=("mysql" "bankapp-demo")
          for app in "${APPS[@]}"; do
            echo "Waiting for ArgoCD app: $app"
            for i in {1..36}; do
              SYNC=$(kubectl get application $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "NotFound")
              HEALTH=$(kubectl get application $app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "NotFound")
              echo "status: sync=$SYNC, health=$HEALTH"
              if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
                echo "$app is Synced and Healthy"
                break
              fi
              sleep 10
              if [ $i -eq 36 ]; then
                echo "Timeout waiting for $app to be healthy/synced"
                kubectl describe application $app -n argocd || true
                kubectl get pods -n ${KUBE_NAMESPACE} || true
                exit 1
              fi
            done
          done

  smoke_tests:
    name: Smoke tests & final checks
    runs-on: [self-hosted]
    needs: apply_argocd_apps
    steps:
      - name: Get pods
        run: kubectl get pods -n ${KUBE_NAMESPACE} -o wide || true

      - name: Wait for bankapp deployment available
        run: kubectl -n ${KUBE_NAMESPACE} rollout status deployment/bankapp --timeout=120s || true

      - name: Wait for mysql deployment available
        run: kubectl -n ${KUBE_NAMESPACE} rollout status deployment/mysql --timeout=120s || true

      - name: Show synced secrets (debug)
        run: kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} -o yaml || true

      - name: Success note
        run: echo "âœ… CD pipeline complete. If you need ArgoCD UI access, follow the instructions in argocd/README.md"
