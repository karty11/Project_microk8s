name: CD
on: workflow_dispatch

jobs:
  test:
    name: Preflight & ArgoCD Setup
    runs-on: self-hosted
    env:
      KUBE_NAMESPACE: devproject
      EXTERNAL_SECRETS_NAMESPACE: external-secrets
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Preflight (git & network)
        run: |
          echo "git: $(git --version)"
          which git || true
          echo "curl check:"
          curl -I https://raw.githubusercontent.com/ || true

      - name: Checkout fresh repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true

      - name: Install Helm (Ubuntu)
        run: |
          sudo snap install helm --classic

      - name: Verify Helm & Kubectl
        run: |
          microk8s kubectl version --client
          helm version

      - name: Ensure required namespaces exist
        run: |
          microk8s kubectl create ns ${KUBE_NAMESPACE} --dry-run=client -o yaml | microk8s kubectl apply -f -
          microk8s kubectl create ns ${EXTERNAL_SECRETS_NAMESPACE} --dry-run=client -o yaml | microk8s kubectl apply -f -
          microk8s kubectl create ns argocd --dry-run=client -o yaml | microk8s kubectl apply -f -

      - name: Check if ArgoCD already installed
        id: check_argocd
        run: |
          if microk8s kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "installed=true" >> $GITHUB_OUTPUT
          else
            echo "installed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install ArgoCD if missing
        if: steps.check_argocd.outputs.installed == 'false'
        run: |
          microk8s kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-server --timeout=4m || true
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-application-controller --timeout=4m || true
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-repo-server --timeout=4m || true

      - name: Wait for ArgoCD deployments
        run: |
          for dep in argocd-server argocd-repo-server argocd-dex-server argocd-redis argocd-applicationset-controller argocd-notifications-controller; do
            microk8s kubectl -n argocd rollout status deployment/$dep --timeout=180s || true
          done
          microk8s kubectl -n argocd rollout status statefulset/argocd-application-controller --timeout=180s || true

      - name: Show ArgoCD pods
        run: microk8s kubectl get pods -n argocd -o wide

  install_and_configure_eso:
    name: Install External Secrets Operator
    runs-on: self-hosted
    needs: test
    env:
      KUBE_NAMESPACE: devproject
      EXTERNAL_SECRETS_NAMESPACE: external-secrets
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ESO_AK: ${{ secrets.AWS_ESO_ACCESS_KEY_ID }}
      AWS_ESO_SK: ${{ secrets.AWS_ESO_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Add external-secrets Helm repo
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
     
      - name: Show kubectl version
        run: microk8s kubectl version --client

      - name: Debug SecretStore file content
        run: |
          echo "==== File Content ===="
          head -n 10 k8s/external-secrets/secretstore-aws.yaml
          echo "======================"
     
      - name: Install External Secrets CRDs safely
        run: |
          for crd in secretstores clustersecretstores externalsecrets; do
            microk8s kubectl create --save-config -f https://raw.githubusercontent.com/external-secrets/external-secrets/main/config/crds/bases/external-secrets.io_${crd}.yaml || true
          done
      
      - name: Check cluster and CRDs
        run: |
          microk8s kubectl get crds | grep secretstores.external-secrets.io || true
    
      - name: Verify SecretStore file version
        run: head -n 5 k8s/external-secrets/secretstore-aws.yaml

      - name: Install/Upgrade external-secrets
        run: |
          helm upgrade --install external-secrets external-secrets/external-secrets \
            -n ${EXTERNAL_SECRETS_NAMESPACE} --create-namespace \
            --wait --timeout 5m

      - name: Wait for ESO controller
        run: |
          microk8s kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} rollout status deployment/external-secrets-controller --timeout=120s || true
          microk8s kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} get pods -o wide

      - name: Create aws-creds secret
        run: |
          if [ -f k8s/external-secrets/aws-creds-secret.yaml ]; then
            microk8s kubectl apply -f k8s/external-secrets/aws-creds-secret.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}
          else
            microk8s kubectl create secret generic aws-creds \
              -n ${EXTERNAL_SECRETS_NAMESPACE} \
              --from-literal=AWS_ACCESS_KEY_ID="${AWS_ESO_AK}" \
              --from-literal=AWS_SECRET_ACCESS_KEY="${AWS_ESO_SK}" \
              --from-literal=AWS_REGION="${AWS_REGION}" \
              --dry-run=client -o yaml | microk8s kubectl apply -f -
          fi

      - name: Apply SecretStore
        run: microk8s kubectl apply -f k8s/external-secrets/secretstore-aws.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}

      - name: Apply ExternalSecret
        run: microk8s kubectl apply -f k8s/external-secrets/external-secret-bankapp.yaml -n ${KUBE_NAMESPACE}

      - name: Wait for bankapp-db-externalsecret
        run: |
          for i in {1..24}; do
            if microk8s kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} >/dev/null 2>&1; then
              echo "Secret exists."
              exit 0
            fi
            echo "Waiting for secret (attempt $i/24)..."
            sleep 5
          done
          echo "ERROR: secret not created after wait" >&2
          microk8s kubectl get externalsecret -n ${KUBE_NAMESPACE} -o yaml || true
          exit 1

  apply_argocd_apps:
    name: Apply ArgoCD Applications
    runs-on: self-hosted
    needs: install_and_configure_eso
    env:
      KUBE_NAMESPACE: devproject
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply MySQL Application
        run: microk8s kubectl apply -f argocd/mysql-application.yaml -n argocd

      - name: Apply Bankapp Application
        run: microk8s kubectl apply -f argocd/bankapp-application.yaml -n argocd

      - name: Wait for ArgoCD apps to sync
        run: |
          set -e
          APPS=("mysql" "bankapp-demo")
          for app in "${APPS[@]}"; do
            for i in {1..36}; do
              SYNC=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "NotFound")
              HEALTH=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "NotFound")
              echo "status: sync=$SYNC, health=$HEALTH"
              if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
                echo "$app is Synced and Healthy"
                break
              fi
              sleep 10
              if [ $i -eq 36 ]; then
                echo "Timeout waiting for $app"
                microk8s kubectl describe application $app -n argocd || true
                microk8s kubectl get pods -n ${KUBE_NAMESPACE} || true
                exit 1
              fi
            done
          done

  smoke_tests:
    name: Smoke Tests & Final Checks
    runs-on: self-hosted
    needs: apply_argocd_apps
    env:
      KUBE_NAMESPACE: devproject
    steps:
      - name: Get pods
        run: microk8s kubectl get pods -n ${KUBE_NAMESPACE} -o wide || true

      - name: Wait for bankapp deployment
        run: microk8s kubectl -n ${KUBE_NAMESPACE} rollout status deployment/bankapp --timeout=120s || true

      - name: Wait for mysql deployment
        run: microk8s kubectl -n ${KUBE_NAMESPACE} rollout status deployment/mysql --timeout=120s || true

      - name: Show synced secrets
        run: microk8s kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} -o yaml || true
