name: CD
on: workflow_dispatch

jobs:
  test:
    name: Preflight & ArgoCD Setup
    runs-on: self-hosted
    env:
      KUBE_NAMESPACE: devproject
      EXTERNAL_SECRETS_NAMESPACE: external-secrets
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Preflight (git & network)
        run: |
          echo "git: $(git --version)"
          which git || true
          echo "curl check:"
          curl -I https://raw.githubusercontent.com/ || true

      - name: Checkout fresh repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
          
      - name: Configure MicroK8s kubeconfig for Helm
        run: |
         mkdir -p ~/.kube
         microk8s config > ~/.kube/config

      - name: Install Helm (Ubuntu)
        run: |
          sudo snap install helm --classic

      - name: Verify Helm & Kubectl
        run: |
          microk8s kubectl version --client
          helm version

      - name: Ensure required namespaces exist
        run: |
          microk8s kubectl create ns ${KUBE_NAMESPACE} --dry-run=client -o yaml | microk8s kubectl apply -f -
          microk8s kubectl create ns ${EXTERNAL_SECRETS_NAMESPACE} --dry-run=client -o yaml | microk8s kubectl apply -f -
          microk8s kubectl create ns argocd --dry-run=client -o yaml | microk8s kubectl apply -f -

      - name: Check if ArgoCD already installed
        id: check_argocd
        run: |
          if microk8s kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "installed=true" >> $GITHUB_OUTPUT
          else
            echo "installed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install ArgoCD if missing
        if: steps.check_argocd.outputs.installed == 'false'
        run: |
          microk8s kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-server --timeout=4m || true
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-application-controller --timeout=4m || true
          microk8s kubectl -n argocd wait --for=condition=available deployment/argocd-repo-server --timeout=4m || true

      - name: Wait for ArgoCD deployments
        run: |
          for dep in argocd-server argocd-repo-server argocd-dex-server argocd-redis argocd-applicationset-controller argocd-notifications-controller; do
            microk8s kubectl -n argocd rollout status deployment/$dep --timeout=180s || true
          done
          microk8s kubectl -n argocd rollout status statefulset/argocd-application-controller --timeout=180s || true

      - name: Show ArgoCD pods
        run: microk8s kubectl get pods -n argocd -o wide

  install_and_configure_eso:
    name: Install External Secrets Operator
    runs-on: self-hosted
    needs: test
    env:
      KUBE_NAMESPACE: devproject
      EXTERNAL_SECRETS_NAMESPACE: external-secrets
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ESO_AK: ${{ secrets.AWS_ESO_ACCESS_KEY_ID }}
      AWS_ESO_SK: ${{ secrets.AWS_ESO_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Add external-secrets Helm repo
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
     
      - name: Show kubectl version
        run: microk8s kubectl version --client

      - name: Debug SecretStore file content
        run: |
          echo "==== File Content ===="
          head -n 10 k8s/external-secrets/secretstore-aws.yaml
          echo "======================"
     
      - name: Install External Secrets CRDs safely
        run: |
          for crd in secretstores clustersecretstores externalsecrets; do
            microk8s kubectl create --save-config -f https://raw.githubusercontent.com/external-secrets/external-secrets/main/config/crds/bases/external-secrets.io_${crd}.yaml || true
          done
      
      - name: Check cluster and CRDs
        run: |
          microk8s kubectl get crds | grep secretstores.external-secrets.io || true
    
      - name: Verify SecretStore file version
        run: head -n 5 k8s/external-secrets/secretstore-aws.yaml

      - name: Install/Upgrade external-secrets
        run: |
           microk8s helm3 upgrade --install external-secrets external-secrets/external-secrets \
           -n ${EXTERNAL_SECRETS_NAMESPACE} --create-namespace \
           --wait --timeout 5m --skip-crds


      - name: Wait for ESO controller
        run: |
          microk8s kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} rollout status deployment/external-secrets-controller --timeout=120s || true
          microk8s kubectl -n ${EXTERNAL_SECRETS_NAMESPACE} get pods -o wide

      - name: Create aws-creds secret
        run: |
          if [ -f k8s/external-secrets/aws-creds-secret.yaml ]; then
            microk8s kubectl apply -f k8s/external-secrets/aws-creds-secret.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}
          else
            microk8s kubectl create secret generic aws-creds \
              -n ${EXTERNAL_SECRETS_NAMESPACE} \
              --from-literal=AWS_ACCESS_KEY_ID="${AWS_ESO_AK}" \
              --from-literal=AWS_SECRET_ACCESS_KEY="${AWS_ESO_SK}" \
              --from-literal=AWS_REGION="${AWS_REGION}" \
              --dry-run=client -o yaml | microk8s kubectl apply -f -
          fi

      - name: Apply SecretStore
        run: microk8s kubectl apply -f k8s/external-secrets/secretstore-aws.yaml -n ${EXTERNAL_SECRETS_NAMESPACE}

      - name: Apply ExternalSecret
        run: microk8s kubectl apply -f k8s/external-secrets/external-secret-bankapp.yaml -n ${KUBE_NAMESPACE}

      - name: Wait for bankapp-db-externalsecret
        run: |
          for i in {1..24}; do
            if microk8s kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} >/dev/null 2>&1; then
              echo "Secret exists."
              exit 0
            fi
            echo "Waiting for secret (attempt $i/24)..."
            sleep 5
          done
          echo "ERROR: secret not created after wait" >&2
          microk8s kubectl get externalsecret -n ${KUBE_NAMESPACE} -o yaml || true
          exit 1

  apply_argocd_apps:
    name: Apply ArgoCD Applications
    runs-on: self-hosted
    needs: install_and_configure_eso
    env:
      KUBE_NAMESPACE: devproject
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply MySQL Application
        run: microk8s kubectl apply -f argocd/mysql-application.yaml -n argocd

      - name: Apply Bankapp Application
        run: microk8s kubectl apply -f argocd/bankapp-application.yaml -n argocd

      - name: Wait for ArgoCD apps to sync
        run: |
          set -e
          APPS=("mysql" "bankapp-demo")
          for app in "${APPS[@]}"; do
            for i in {1..36}; do
              SYNC=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "NotFound")
              HEALTH=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "NotFound")
              echo "status: sync=$SYNC, health=$HEALTH"
              if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
                echo "$app is Synced and Healthy"
                break
              fi
              sleep 10
              if [ $i -eq 36 ]; then
                echo "Timeout waiting for $app"
                microk8s kubectl describe application $app -n argocd || true
                microk8s kubectl get pods -n ${KUBE_NAMESPACE} || true
                exit 1
              fi
            done
          done

  # smoke_tests:
  #   name: Smoke Tests & Final Checks
  #   runs-on: self-hosted
  #   needs: apply_argocd_apps
  #   env:
  #     KUBE_NAMESPACE: devproject
  #   steps:
  #     - name: Get pods
  #       run: microk8s kubectl get pods -n ${KUBE_NAMESPACE} -o wide || true

  #     - name: Wait for bankapp deployment
  #       run: microk8s kubectl -n ${KUBE_NAMESPACE} rollout status deployment/bankapp --timeout=120s || true

  #     - name: Wait for mysql deployment
  #       run: microk8s kubectl -n ${KUBE_NAMESPACE} rollout status deployment/mysql --timeout=120s || true

  #     - name: Show synced secrets
  #       run: microk8s kubectl get secret bankapp-db-externalsecret -n ${KUBE_NAMESPACE} -o yaml || true

  apply_datalake_apps:
    name: Deploy Data Lake Components (Airflow, MinIO, Trino, Grafana, Prometheus)
    runs-on: self-hosted
    needs: apply_argocd_apps
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure namespaces for data lake
        run: |
          for ns in airflow minio trino monitoring; do
            microk8s kubectl create ns $ns --dry-run=client -o yaml | microk8s kubectl apply -f -
          done

      - name: Apply Airflow Application
        run: microk8s kubectl apply -f argocd/airflow-application.yaml -n argocd

      - name: Apply MinIO Application
        run: microk8s kubectl apply -f argocd/minio-application.yaml -n argocd

      - name: Apply Trino Application
        run: microk8s kubectl apply -f argocd/trino-application.yaml -n argocd

      - name: Apply Grafana Application
        run: microk8s kubectl apply -f argocd/grafana-application.yaml -n argocd

      - name: Apply Prometheus Application
        run: microk8s kubectl apply -f argocd/prometheus-application.yaml -n argocd

      - name: Wait for Prometheus Stack to be Ready
        run: |
          microk8s kubectl -n monitoring rollout status deployment prometheus-stack-kube-prometheus-operator --timeout=180s || true
          microk8s kubectl get pods -n monitoring
        
      - name: Apply Grafana Dashboards Application
        run: microk8s kubectl apply -f argocd/grafana-dashboards-application.yaml -n argocd

      - name: Apply Airflow DAGs Application
        run: microk8s kubectl apply -f argocd/data-pipeline-dags-application.yaml -n argocd

      - name: Wait for Data Lake Apps to Sync
        run: |
          set -e
          APPS=("airflow" "minio" "trino" "grafana" "prometheus-stack" "grafana-dashboards" "data-pipeline-dags")
          for app in "${APPS[@]}"; do
            for i in {1..40}; do
              SYNC=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "NotFound")
              HEALTH=$(microk8s kubectl get application $app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "NotFound")
              echo "status: $app sync=$SYNC, health=$HEALTH"
              if [[ "$SYNC" == "Synced" && "$HEALTH" == "Healthy" ]]; then
                echo "$app is Synced and Healthy"
                break
              fi
              sleep 10
              if [ $i -eq 40 ]; then
                echo "Timeout waiting for $app"
                microk8s kubectl describe application $app -n argocd || true
                microk8s kubectl get pods -A || true
                exit 1
              fi
            done
          done
     
      - name: Apply Data Lake ServiceMonitors
        run: |
          microk8s kubectl apply -f k8s/monitoring/servicemonitor-airflow.yaml
          microk8s kubectl apply -f k8s/monitoring/servicemonitor-minio.yaml
          microk8s kubectl apply -f k8s/monitoring/servicemonitor-trino.yaml
          
  smoke_tests:
    name: Smoke Tests & Final Checks
    runs-on: self-hosted
    needs: apply_datalake_apps
    env:
      KUBE_NAMESPACE: devproject
    steps:
      - name: Get pods across all namespaces
        run: microk8s kubectl get pods -A -o wide

      - name: Wait for Bankapp deployment
        run: microk8s kubectl -n ${KUBE_NAMESPACE} rollout status deployment/bankapp --timeout=120s || true

      - name: Wait for Airflow Webserver
        run: microk8s kubectl -n airflow rollout status deployment/airflow-web --timeout=180s || true

      - name: Wait for Trino Coordinator
        run: microk8s kubectl -n trino rollout status deployment/demo-trino-coordinator --timeout=180s || true

      - name: Wait for Grafana
        run: microk8s kubectl -n monitoring rollout status deployment/demo-grafana --timeout=180s || true

      - name: Check Prometheus Targets
        run: microk8s kubectl -n monitoring port-forward svc/prometheus-stack-kube-prometheus-prometheus 9090:9090 &
              sleep 10 && curl -s http://localhost:9090/api/v1/targets | jq '.data.activeTargets | length'

      - name: Final Summary
        run: |
          echo "All core + data lake + monitoring components deployed successfully."
          microk8s kubectl get pods -A

  
